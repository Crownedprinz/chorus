<project name="Chorus Build" default="build">

	<!-- ***************************************************************** -->
	<!-- ********* Set a few properties						   *********** -->
	<!-- ***************************************************************** -->
	<!-- Project build dir is the dir where the build script is located -->
	<property name="project.bld.dir"  value="${project::get-base-directory()}"/>

	<!-- Project base dir is the build dir's parent -->
	<property name="project.base.dir" value="${path::get-directory-name(project.bld.dir)}"/>

	<!-- Project source dir is a child of the base dir -->
	<property name="project.src.dir" value="${path::combine(project.base.dir,'src')}" />

	<!-- Project lib dir is a child of the base dir -->
	<property name="project.lib.base.dir" value="${path::combine(project.base.dir,'lib')}"/>

	<!-- OS Platform in Use -->
	<property name="os.platform" value="other"/>
	<if test="${platform::is-win32()}">
		<property name="os.platform" value="win32"/>
		<!-- Default runtime configuration -->
		<property name="runtime.config" value="net-2.0"/>
	</if>
	<if test="${platform::is-unix()}">
		<property name="os.platform" value="linux"/>
		<!-- Default runtime configuration -->
		<property name="runtime.config" value="mono-2.0"/>
	</if>

	<!-- List of buildfiles for the individual projects. Order is relevant!-->
	<fileset id="project.buildfiles.src" basedir="${project.src.dir}">
		<include name="LibChorus/LibChorus.proj.build" />
		<include name="ChorusMerge/ChorusMerge.proj.build" />
		<include name="Chorus/Chorus.proj.build" />
		<include name="LibChorusTests/LibChorus.Tests.proj.build" />
		<include name="ChorusMerge.Tests/ChorusMerge.Tests.proj.build" />
		<include name="Chorus.Tests/Chorus.Tests.proj.build" />
	</fileset>

	<target name="clean" description="Delete all previously compiled binaries.">
		<delete>
			<fileset>
				<exclude name="../.hg/**" />
				<exclude name="../lib/**" />
				<include name="../**/bin/**" />
				<include name="../**/obj/**" />
				<include name="../output/**" />
				<include name="../release/output/*" />
			</fileset>
		</delete>

		<nant target="clean">
			<buildfiles refid="project.buildfiles.src" />
		</nant>
	</target>

	<target name="revision_svn">
		<property name="svn.info.log" value="svninfo.txt"/>
		<exec
			program="svn.exe"
			basedir="C:\Program Files\Subversion\bin"
			commandline="info http://code.wesay.org/Palaso/trunk/Palaso"
			output="${svn.info.log}"
		/>
		<loadfile property="svn.head.revision" file="${svn.info.log}" />
		<regex pattern="^Revision: (?'revision'.*)$" input="${svn.head.revision}" options="Multiline" />
		<property name="revision" value="${string::trim(revision)}" />
		<echo message="Revision: ${revision}" />
		<delete file="${svn.info.log}" />
	</target>

	<target name="revision_teamcityhg">
		<property name="teamcity" value="${environment::get-variable('BUILD_NUMBER')}" />
		<regex pattern="^(?'revision'[^:]*)" input="${teamcity}" />
		<property name="revision" value="${string::trim(revision)}" />
		<echo message="Revision: ${revision}" />
	</target>

	<target name="version" depends="revision_teamcityhg">
		<loadfile property="version" file="version.txt">
			<filterchain>
				<expandproperties />
			</filterchain>
		</loadfile>
		<property name="version" value="${string::trim(version)}" />
		<echo message="Version: ${version}" />
	</target>

	<target name="assemblyinfo" depends="version">
		<foreach item="File" property="filename">
			<in>
				<items>
					<include name="../**/AssemblyInfo.cs" />
					<exclude name="../.hg/**/*" />
				</items>
			</in>
			<do>
				<script language="C#">
				<code><![CDATA[
				public static void ScriptMain(Project project)
				{
					StreamReader reader = new StreamReader(project.Properties["filename"]);
					string contents = reader.ReadToEnd();
					reader.Close();
					string replacement;
					string newText = contents;
					replacement = string.Format(
						"[assembly: AssemblyVersion(\"{0}\")]",
						project.Properties["version"]
					);
					newText = Regex.Replace(newText, @"\[assembly: AssemblyVersion\("".*""\)\]", replacement);
					replacement = string.Format(
						"[assembly: AssemblyFileVersion(\"{0}\")]",
						project.Properties["version"]
					);
					newText = Regex.Replace(newText, @"\[assembly: AssemblyFileVersion\("".*""\)\]", replacement);
					StreamWriter writer = new StreamWriter(project.Properties["filename"], false);
					writer.Write(newText);
					writer.Close();
				}
				]]>
				</code>
				</script>
			</do>
		</foreach>
	</target>

	<target name="build" description="Build all targets." depends="assemblyinfo" >
		<call target="build-only"/>
	</target>

	<target name="rebuild" depends="clean, build" />

	<target name="build-only" depends="make-output-dir, set-build-config, set-runtime-config, copy-lib-files">
		<nant target="build">
			<properties>
				<property name="build.defines" value="${build.defines}" />
				<property name="build.debug" value="${build.debug}" />
				<property name="build.debug" value="${build.debug}" />
				<!-- <property name="project.lib.dir" value="${project.lib.dir}" /> -->
				<property name="project.output.dir" value="${project.output.dir}" />
			</properties>
			<buildfiles refid="project.buildfiles.src" />
		</nant>
		<echo message="${project.output.dir}" />
		<property name="expected.output" value="${project.output.dir}/LibChorus.dll"/>
		<fail unless="${file::exists(expected.output)}">Output file doesn't exist in ${expected.output}</fail>
		<property name="expected.output" value="${project.output.dir}/ChorusMerge.exe"/>
		<fail unless="${file::exists(expected.output)}">Output file doesn't exist in ${expected.output}</fail>
		<property name="expected.output" value="${project.output.dir}/Chorus.exe"/>
		<fail unless="${file::exists(expected.output)}">Output file doesn't exist in ${expected.output}</fail>
	</target>

	<target name="build-for-wesay" depends="build-only">
		<copy todir="${project.base.dir}/../wesay/lib/mono">
			<fileset basedir="${project.output.dir}">
				<include name="LibChorus.dll" />
				<include name="Chorus.exe" />
				<include name="ChorusMerge.exe" />
			</fileset>
		</copy>
		<copy todir="${project.base.dir}/../wesay/output/linux/mono/2.0/Debug">
			<fileset basedir="${project.output.dir}">
				<include name="LibChorus.dll" />
				<include name="Chorus.exe" />
				<include name="ChorusMerge.exe" />
			</fileset>
		</copy>
	</target>

	<target name="test" depends="build-only">
		<call target="test-only-with-fail"/>
	</target>

	<target name="test-only-no-fail" depends="make-output-dir, set-build-config, set-runtime-config">
		<!-- Run tests the first time without stopping the build under on failing tests because we want to be able to see ALL failing tests in the log.
		The downside to this is that TeamCity will show a passing build even with failing tests-->

		<echo message="*********************************************************************"/>
		<echo message="******                  Begin Test Run 	                    ********"/>
		<echo message="*********************************************************************"/>

		<foreach item="File" property="filename">
			<in>
				<items>
					<include name="${project.output.dir}/*.Tests.dll" />
				</items>
			</in>
			<do>
				<nunit2 failonerror="false" verbose="true">
				<formatter type="Plain"/>
				<test>
				<assemblies>
					<include name="${filename}" />
				</assemblies>
				<categories>
					<exclude name="Mono Known Issue"/>
				</categories>
				</test>
				</nunit2>
			</do>
		</foreach>
	</target>

	<target name="test-only-with-fail" depends="make-output-dir, set-build-config, set-runtime-config">
		<echo message="*********************************************************************"/>
		<echo message="******                  Test With Fail                       ********"/>
		<echo message="*********************************************************************"/>

		<!-- Run the tests a second time, failing as soon as possible. We do this so that TeamCity indicates a failed build on failing tests-->
		<nunit2 haltonfailure="true" failonerror="true">
			<formatter type="Plain" usefile="false" />
			<test>
			<assemblies>
				<include name="${project.output.dir}/*.Tests.dll" />
			</assemblies>
			<categories>
				<exclude name="Mono Known Issue"/>
			</categories>
			</test>
		</nunit2>
	</target>

	<target name="installerpre" depends="version">
		<fail />
		<foreach item="File" property="filename">
			<in>
				<items>
					<include name="../release/*.iss" />
				</items>
			</in>
			<do>
				<property name="backupname" value="${string::replace(filename, 'iss', 'iss.bak')}" />
				<copy file="${filename}" tofile="${backupname}" overwrite="true" />
				<copy file="${backupname}" tofile="${filename}" overwrite="true">
					<filterchain>
						<expandproperties />
					</filterchain>
				</copy>
			</do>
		</foreach>
	</target>

	<target name="installerpost">
		<fail />
		<foreach item="File" property="filename">
			<in>
				<items>
					<include name="../release/*.iss" />
				</items>
			</in>
			<do>
				<property name="backupname" value="${string::replace(filename, 'iss', 'iss.bak')}" />
				<copy file="${backupname}" tofile="${filename}" overwrite="true" />
				<delete file="${backupname}" />
			</do>
		</foreach>
	</target>

	<target name="installer.win">
		<fail />
		<exec program="C:\Program Files\Inno Setup 5\ISCC.exe" append="true">
			<arg file="../release/solid.iss" />
		</exec>
	</target>

	<target name="installer" depends="test">
		<call target="installerpre" />
		<call target="installer.win" />
		<call target="installerpost" />
	</target>

	<target name="publish" depends="installer">
		<exec program="ftp.exe">
			<arg line="-n -s:ftp.txt" />
		</exec>
	</target>

<!-- ***************************************************************** -->
<!-- ********* Targets for setting the build configuration *********** -->
<!-- ***************************************************************** -->

	<!-- Default build configuration -->
	<property name="build.config" value="Debug"/>
	<property name="build.defines" value=""/>

  <target name="set-build-config">
	<call target="set-${build.config}-build-config"/>
  </target>

  <target name="set-Debug-build-config">
	<echo message="Setting configuration to Debug."/>
	<property name="build.config" value="Debug"/>
	<property name="build.debug" value="true"/>
	<property name="build.defines" value="DEBUG,TRACE,${runtime.defines}"
		dynamic="true"/>
	<property name="zip.build.suffix" value="-dbg"/>
	<property name="msi.build.suffix" value="-dbg"/>
  </target>

  <target name="set-release-build-config">
	<echo message="Setting configuration to Release."/>
	<property name="build.config" value="Release"/>
	<property name="build.debug" value="false"/>
	<property name="build.defines" value="TRACE,${runtime.defines}"
	dynamic="true"/>
	<property name="zip.build.suffix" value=""/>
	<property name="msi.build.suffix" value=""/>
  </target>

<!-- ***************************************************************** -->
<!-- ***    Targets for setting the runtime configuration          *** -->
<!-- ***************************************************************** -->


	<!-- Default runtime configuration -->
	<property name="runtime.config" value="mono-2.0"/>

  <target name="set-runtime-config">
	<call target="set-${runtime.config}-runtime-config"/>
  </target>

  <target name="set-default-dot-net-runtime-config">
	<fail unless="${property::exists( 'default.net.runtime' )}"
	  message="No versions of the .NET SDK were found"/>

	<call target="set-${default.net.runtime}-runtime-config" />
  </target>

  <target name="set-default-mono-runtime-config">
	<fail unless="${property::exists( 'default.mono.runtime' )}"
	  message="No versions of the Mono runtime were found"/>

	<call target="set-${default.mono.runtime}-runtime-config" />
  </target>

  <target name="set-net-1.0-runtime-config">
	<fail unless="${framework::sdk-exists( 'net-1.0' )}"
	  message="The .NET 1.0 SDK is not configured or not installed"/>

	<property name="runtime.platform" value="net"/>
	<property name="runtime.version" value="1.0"/>
	<property name="runtime.config" value="net-1.0"/>
	<property name="runtime.defines" value="NET,NET_1_0"/>
	<property name="build.mono" value="false"/>
	<property name="build.win32" value="true"/>
	<property name="build.gui" value="false"/>
	<property name="build.x86" value="false"/>
	<property name="nant.settings.currentframework"
	  value="net-1.0"/>
	<property name="zip.runtime.suffix" value="-net-1.0"/>
	<property name="msi.runtime.suffix" value="-net-1.0"/>
	<property name="supported.test.platforms"
	  value="net-1.0,net-1.1,net-2.0,mono-1.0,mono-2.0"/>
	<call target="set-test-platforms"/>
  </target>

  <target name="set-net-1.1-runtime-config">
	<property name="runtime.platform" value="net"/>
	<fail unless="${framework::sdk-exists( 'net-1.1' )}"
	  message="The .NET 1.1 SDK is not configured or not installed"/>

	<property name="runtime.platform" value="net"/>
	<property name="runtime.version" value="1.1"/>
	<property name="runtime.config" value="net-1.1"/>
	<property name="runtime.defines" value="NET,NET_1_1"/>
	<property name="build.mono" value="false"/>
	<property name="build.win32" value="true"/>
	<property name="build.gui" value="true"/>
	<property name="build.x86" value="false"/>
	<property name="nant.settings.currentframework"
	  value="net-1.1"/>
	<property name="zip.runtime.suffix" value="-net-1.1"/>
	<property name="msi.runtime.suffix" value="-net-1.1"/>
	<property name="supported.test.platforms"
	  value="net-1.0,net-1.1,net-2.0,mono-1.0,mono-2.0"/>
	<call target="set-test-platforms"/>
  </target>

  <target name="set-net-2.0-runtime-config">
	<fail unless="${framework::sdk-exists( 'net-2.0' )}"
	  message="The .NET 2.0 SDK is not configured or not installed"/>

	<property name="runtime.platform" value="net"/>
	<property name="runtime.version" value="2.0"/>
	<property name="runtime.config" value="net-2.0"/>
	<property name="runtime.defines" value="NET,NET_2_0"/>
	<property name="build.mono" value="false"/>
	<property name="build.win32" value="true"/>
	<property name="build.gui" value="true"/>
	<property name="build.x86" value="true"/>
	<property name="nant.settings.currentframework"
	  value="net-2.0"/>
	<property name="zip.runtime.suffix" value="-net-2.0"/>
	<property name="msi.runtime.suffix" value="-net-2.0"/>
	<property name="supported.test.platforms" value="net-2.0,mono-2.0"/>
	<call target="set-test-platforms"/>
  </target>

  <target name="set-mono-1.0-runtime-config">
	<fail unless="${framework::sdk-exists( 'mono-1.0' )}"
	  message="The Mono 1.0 SDK is not configured or not installed"/>

	<property name="runtime.platform" value="mono"/>
	<property name="runtime.version" value="1.0"/>
	<property name="runtime.config" value="mono-1.0"/>
	<property name="runtime.defines" value="MONO,MONO_1_0"/>
	<property name="build.mono" value="true"/>
	<property name="build.win32" value="false"/>
	<property name="build.gui" value="true"/>
	<property name="build.x86" value="false"/>
	<property name="nant.settings.currentframework"
	  value="mono-1.0"/>
	<property name="zip.runtime.suffix" value="-mono-1.0"/>
	<property name="msi.runtime.suffix" value="-mono-1.0"/>
	<property name="supported.test.platforms"
	  value="mono-1.0,mono-2.0,net-1.0,net-1.1,net-2.0"/>
	<call target="set-test-platforms"/>
  </target>

  <target name="set-mono-2.0-runtime-config">
	<fail unless="${framework::sdk-exists( 'mono-2.0' )}"
	  message="The Mono 2.0 SDK is not configured or not installed"/>

	<property name="runtime.platform" value="mono"/>
	<property name="runtime.version" value="2.0"/>
	<property name="runtime.config" value="mono-2.0"/>
	<property name="runtime.defines" value="MONO,MONO_2_0"/>
	<property name="build.mono" value="true"/>
	<property name="build.win32" value="false"/>
	<property name="build.gui" value="true"/>
	<property name="build.x86" value="true"/>
	<property name="nant.settings.currentframework"
	  value="mono-2.0"/>
	<property name="zip.runtime.suffix" value="-mono-2.0"/>
	<property name="msi.runtime.suffix" value="-mono-2.0"/>
	<property name="supported.test.platforms" value="mono-2.0,net-2.0"/>
  </target>

<!-- ***************************************************************** -->
<!-- ***    Targets for setting the output directory               *** -->
<!-- ***************************************************************** -->
  <target name="set-output-dir" depends="set-build-config,set-runtime-config">
	<property name="base.output.dir"
	  value="${path::combine(project.base.dir,'output')}"/>
	 <property name="os.platform.dir"
	  value="${path::combine(base.output.dir,os.platform)}"/>
	<property name="runtime.platform.dir"
	  value="${path::combine(os.platform.dir,runtime.platform)}"/>
	<property name="runtime.version.dir"
	  value="${path::combine(runtime.platform.dir,runtime.version)}"/>
	<property name="project.output.dir"
	  value="${path::combine(runtime.version.dir,build.config)}"/>
	 <property name="project.documentation.dir"
	  value="${path::combine(project.output.dir,'doc')}"/>
	 <property name="project.resource.dir"
	  value="${path::combine(project.output.dir,'resources')}"/>
  </target>

  <target name="make-output-dir" depends="set-output-dir">
	<mkdir dir="${project.output.dir}"
	  unless="${directory::exists(project.output.dir)}"/>
	 <mkdir dir="${project.documentation.dir}"
	  unless="${directory::exists(project.documentation.dir)}"/>
	 <mkdir dir="${project.resource.dir}"
	  unless="${directory::exists(project.resource.dir)}"/>
  </target>

<!-- ***************************************************************** -->
<!-- ***    Targets for copying lib files to output directory      *** -->
<!-- ***************************************************************** -->

<target name="copy-lib-files" depends="make-output-dir, set-runtime-config">
	<call target="copy-${runtime.platform}-lib-files"/>
</target>

<target name="copy-mono-lib-files" depends="make-output-dir, set-build-config, set-runtime-config">
	<echo message="${project.lib.base.dir} platform ${runtime.platform}" />
	<copy todir="${project.output.dir}" flatten="true">
		<fileset basedir="${project.lib.base.dir}">
			<include name="mono/*" />
			<include name="common/*" />
		</fileset>
	</copy>
	<echo message="${project.bld.dir} platform ${runtime.platform}" />
	<copy file="${project.bld.dir}/chorusmerge.mono.runner.fortests" tofile="${project.output.dir}/chorusmerge" />
	<exec program="chmod" commandline="755 ${project.output.dir}/chorusmerge" />
</target>

<target name="copy-windows-lib-files" depends="make-output-dir, set-build-config, set-runtime-config">
	<echo message="${project.lib.base.dir} platform ${runtime.platform}" />
	<copy todir="${project.output.dir}" flatten="true">
		<fileset basedir="${project.lib.base.dir}">
			<include name="net2.0/*" />
			<include name="common/*" />
		</fileset>
	</copy>
</target>

</project>
